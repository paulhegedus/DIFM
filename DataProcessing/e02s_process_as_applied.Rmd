# Process raw as-planted seed rate data

## Read in datasets

### As-planted data

```{r Reading-as-planted-datasets}
#--- as-planted ---#
asp <- here("Data/Growers", ffy, "Raw") %>% 
  list.files(recursive = TRUE, full.names = TRUE) %>%
  #--- search for as-applied-s file ---#
  .[str_detect(., "shp")] %>%
  .[!str_detect(., "xml")] %>%
  .[str_detect(., "as-applied-s")] %>% 
  #--- read the data ---#
  st_read() %>% 
  st_set_4326() %>% 
  st_transform_utm() %>%
  setnames(names(.), tolower(names(.))) %>% 
  mutate(id = 1:nrow(.))

#--- get variable names ---#
asp_names <- names(asp)
```

```{r visialize-seed-as-planted-data}
#--- visualize the points ---#
tm_shape(asp) +
  tm_dots()    
```   

### Medium distance of yield polygons

```{r }
#--- medium distance of yield polygons ---#
med_distance_yp <- get_med_dist(yield_polygons)
```


## Miscellaneous operations and various checks



### Change variable names

time variable needs to be dealt with separately

```{r }
if("time" %in% names(asp) & "isotime" %in% names(asp)) {
  asp <- dplyr::select(asp, - time) 
  time_available <- TRUE
}

dict_asp <- dictionary[type == "seed_rate", ]
col_list <- dict_asp[, column]

asp <- make_var_name_consistent(
  asp,
  dict_asp
)

asp <- dplyr::select(asp, matches(c(col_list, "sectionid", "id")))

```

###  Check units

This code assumes that if `distance` is in meter, then other variables (e.g., `width`) are also measured in meter.

```{r }
#--- check units of data ---#
dist_test <- asp %>% 
  cbind(., st_coordinates(.)) %>% 
  data.table() %>% 
  .[, dif_X := c(0, diff(X))] %>% 
  .[, dif_Y := c(0, diff(Y))] %>%  
  #--- distance in meter ---#
  .[, distance_r := sqrt(dif_X ^ 2 + dif_Y ^ 2)] %>%
  #--- dif in difference in meter and recorded distance ---#
  .[, dif_distance := abs(distance - distance_r)] %>%
  .[, dif_distance_conv := abs(conv_unit(distance, "ft", "m") - distance_r)]

# we want to see if the converted units from ft to meter are closer to the distance measured in r
if (mean(dist_test$dif_distance_conv, na.rm = TRUE) < mean(dist_test$dif_distance, na.rm = TRUE)){
  units <- "imperial"
} else {
  units <- "metric"
}

```

### Transform measurement unit

```{r }
if (units == "imperial") {
  asp <- asp %>%
    mutate(
      width = conv_unit(width, "ft", "m"),
      distance = conv_unit(distance, "ft", "m"),
      offset = conv_unit(offset, "ft", "m")
    )
}

#--- seed rate conversion ---#
if (any(asp$seed_rate > 10000)){
  #--- convert to K ---#
  asp <- mutate(asp, seed_rate = seed_rate / 1000)
}

```

## Group points by changes in angle

### Check the density of data points and the presence of section control  

Definitions:

+ dense: if the distance between points in the direction you are moving is very small 


```{r }
is_section_controlled <- "sectionid" %in% names(asp)

if (is_section_controlled) {
  #--- medium distance between asp points ---#
  med_distance_asp_v <- get_med_dist_sec(asp)
  med_distance_asp_h <- get_med_dist(asp)
  ratio <- med_distance_asp_v / med_distance_asp_h

  #--- number of sections ---#
  section_num <- data.table(asp)[, .(nobs = .N), by = .(angle)][, median(nobs)]

  if (ratio < 1.01 & ratio > 0.99) {
    # Note: if the ratio \sim 1, then it means we have only 1 observation per row
    section_num <- 1
    med_distance_asp_v <- get_med_dist(asp)
  }

} else {
  #--- medium distance between asp points ---#
  med_distance_asp_v <- get_med_dist(asp)

  #--- number of sections ---#
  section_num <- 1
}

is_dense <- (med_distance_asp_v * 2) < med_distance_yp

#/*----------------------------------*/
#' ## Width correction
#/*----------------------------------*/
if (section_num != 1) {

  # Note: this works as there are many observations at a single application time
  med_distance_asp_h <- get_med_dist(asp) 

  asp <- mutate(asp, width = med_distance_asp_h)

} else {
  # if only one observation 
  asp <- mutate(asp, 
    width = input_data_s$machine_width %>% 
      conv_unit("ft", "m")
  )
}

```

### Group points by changes in angle 

```{r }
if (section_num != 1) {
  #--- if section-controlled and more than one section observations at a time ---#
  asp_grouped <- group_points_sc(asp, "sectionid", angle_threshold = 30) %>% 
    #--- remove observations with no group assigned ---#
    mutate(
      new_group = paste(group, sectionid, sep = "_")
    )
} else {
  #--- if only one observation at a time ---#
  asp_grouped <- group_points_sc(asp, by_var = NA, angle_threshold = 30) %>% 
    #--- remove observations with no group assigned ---#
    mutate(
      new_group = group
    )
}

```

Red points are those that are recognized for making a sharp turn from their respective previous points.

```{r }
tm_shape(asp_grouped) +
    tm_dots(col = "blue") +
tm_shape(filter(asp_grouped, change_group == TRUE)) +
    tm_dots(col = "red", size = 0.1) +
tm_layout_to_add 
```

## Flag bad yield data points 

```{r }
sd_factor <- 4

asp_grouped <- flag_bad_points(
  asp_grouped, 
  "seed_rate", 
  sd = sd_factor
)  
```

Yield distribution after cleaning:

```{r }
asp_grouped %>% filter(flag_bad == 0) %>% 
  pull(seed_rate) %>% 
  hist()

asp_grouped %>% 
  pull(seed_rate) %>% 
  hist()
```

`speed` vs `seed_rate`

```{r }
speed_n_before <- ggplot(asp_grouped) +
  geom_point(aes(y = seed_rate, x = speed))

speed_n_after <- ggplot(filter(asp_grouped, flag_bad == 0)) +
  geom_point(aes(y = seed_rate, x = speed))

speed_n_before | speed_n_after
```

Which data points were flagged as **bad** (right image)?

```{r }
tm_before <- tm_shape(asp_grouped) +
  tm_symbols(col = "seed_rate", size = 0.05) +
tm_layout_to_add 

tm_after <- tm_shape(filter(asp_grouped, flag_bad == 1)) +
  tm_symbols(col = "seed_rate", size = 0.05) +
tm_layout_to_add  

tmap_arrange(tm_before, tm_after)
```
 
```{r }
datasummary(
  seed_rate + width + speed + angle 
  ~ Mean + SD + median,
  data = asp_grouped
)  
```

## Vertically reduce points if dense (parallel to the direction the planter is moving) 

```{r }
if (is_dense) {
  num_obs_rg <- ceiling(2 / (med_distance_v))

  asp_reduced_v <- reduce_points_v(asp_grouped, num_obs_rg, "seed_rate", "new_group") %>% 
    .[, .SD[.N != 1, ], by = new_group]

} else {

  asp_reduced_v <- data.table(asp_grouped) %>% 
    .[, .SD[.N != 1, ], by = new_group]

}
  
```

## Create polygons

```{r }
#--- prepare parallel computation ---#
plan(multiprocess, workers = detectCores() - 2)

#--- create polygons ---#
all_polygons <- future_lapply(
  #--- list of groups to loop over ---#
  asp_reduced_v$new_group %>% unique(), 
  #--- make polygons by group ---#
  function(x) make_polygons(
    filter(asp_reduced_v, new_group == x)
  )
) %>% 
reduce(c) %>% 
st_as_sfc() 

#--- combine with the data ---#
asp_sf <- asp_reduced_v %>% 
  mutate(geometry = all_polygons) %>% 
  st_as_sf() %>% 
  st_set_crs(st_crs(asp)) %>% 
  #--- get rid of transition polygons by area ---#
  mutate(area = as.numeric(st_area(.))) %>% 
  filter(area <= median(area) * 3) %>% 
  mutate(asp_id = 1:nrow(.)) %>% 
  filter(!st_is_empty(.)) %>% 
  filter(flag_bad == 0) %>% 
  dplyr::select(asp_id, seed_rate)

```

```{r }
tm_shape(asp_sf) +
  tm_polygons(
    lwd = 0.05,
    col = "seed_rate"
  ) +
tm_layout_to_add

```

## Save the data

```{r }
here("Data/Growers", ffy, "Intermediate/as_applied_s.rds") %>% 
saveRDS(asp_sf, .)
```
